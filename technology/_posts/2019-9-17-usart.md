---
layout: post
title: USART （轮询 中断 DMA）
description: >
  DMA不定长接受，printf轮询发送，码云地址https://gitee.com/buffzhou/DMA_try

---
# USART （轮询 中断 DMA）

-----------
## 快速目录
{:.no_t
oc}
1. this unordered seed list will be replaced by toc as unordered list
{:toc}

-----------
## USART三种收发方式简介

接受发送数据就像你去收发快递，发送还好说因为你知道自己什么时候发快递，这样就能很好的安排什么时候发快递，你完全可以控制发快递的时间不会影响你的工作。但是接受数据是个麻烦的事情，因为是别人发送的数据如果你不去收它就没了，而且这完全是不可控的，也就是说无法预料，为了不干扰你当前的工作我们一般用DMA接受。下面我举个栗子。
轮询接受：你在工作的安排中不停的询问有没有你的快递，在程序中就是一段语句看寄存器上有没有信号，缺点使你工作效率低下，而且没询问的时候消息就没有收到。
中断接受：中断像个宿管大爷，他不会帮你保存，一来快递就喊你下来拿，如果你不来就没有了。这样的话你可能在写作业，突然下来拿快递效率也很低。
DMA接受：这就像菜鸟驿站，菜鸟驿站帮你保存，包裹接受的过程都不用你做，你只要快速的在一个包裹接受结束时吧包裹拿走。

**下面是喜闻乐见的“shut up and shoe your code”环节**
MX配置就是USRAT打开DMA**要打开USRAT中断**不然空闲中断没法触发

---

## 发送（重定义printf中fputc）

~~~c

#ifdef __GNUC__
	#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
	#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif

PUTCHAR_PROTOTYPE
{
	HAL_UART_Transmit(&huart1, (uint8_t *)&ch , 1 , 0xFFFF);
	return ch;
}

~~~
   
---

## 接受

~~~c

void UsartReceive_IDLE(UART_HandleTypeDef *huart)
{
    uint32_t temp;

    if((__HAL_UART_GET_FLAG(huart,UART_FLAG_IDLE) != RESET))
    {
        __HAL_UART_CLEAR_IDLEFLAG(&huart1);
        HAL_UART_DMAStop(&huart1);
        temp = huart1.hdmarx->Instance->CNDTR;
        UsartType.RX_Size =  RX_LEN - temp;
        UsartType.RX_flag=1;
        HAL_UART_Receive_DMA(&huart1,UsartType.RX_pData,RX_LEN);
    }
}

~~~
---

